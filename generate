#!/usr/bin/perl
use strict;
use Cwd;
use JSON;
use Hash::Merge;
use Data::Dumper;
use Clone qw(clone);
use IPC::Open3;
use IO::Select;

my $RUN = time();

my $ROOT = "test.sslresearch.org";
my $DOMAIN = ".$ROOT";
my $CRL_PATH = "http://test.sslresearch.org/crls/$RUN-";

my $NORESPONSE_PORT = "10000";

my $CRLSERIAL_FILE = ".crlserial";
my $SERIAL_FILE = ".serial";
my $DATABASE_FILE = ".database";
my $CONF_FILE = ".conf";

my $KEY_DIR = "keys";
my $CACERT_DIR = "ca-certs";
my $CERT_DIR = "certs";
my $CSR_DIR = "csrs";
my $DATA_DIR = cwd() . "/data";
my $OUT_DIR = cwd() . "/out";

my $MD = "sha256";

my $OIDS_NAME = "new_oids";
my %OIDS = ("postalCode" => "2.5.4.17", "businessCategory" => "2.5.4.15", "streetAddress" => "2.5.4.9", "stateOrProvinceName" => "2.5.4.8", "countryName" => "2.5.4.6", "jurisdictionOfIncorporationStateOrProvinceName" => "1.3.6.1.4.1.311.60.2.1.2",  "jurisdictionOfIncorporationLocalityName" => "1.3.6.1.4.1.311.60.2.1.1", "jurisdictionOfIncorporationCountryName" => "1.3.6.1.4.1.311.60.2.1.3");

my $POLICY_NAME = "policy_match";
my %POLICY = ("countryName" => "optional", "stateOrProvinceName" => "optional", "organizationName" => "optional", "organizationalUnitName" => "optional", "commonName" => "supplied", "emailAddress " => "optional");

my $DIRNAME_NAME = "dir_name";
my %DIRNAME = ("CN" => "Class3CA2048-1-47");

my $CERTPOL_NAME = "polsect";
my %CERTPOL = ("policyIdentifier" => "2.16.840.1.113733.1.7.23.6", "CPS.1" => "https://www.verisign.com/cps");

my $CACERTPOL_NAME = "polsectca";
my %CACERTPOL = ("policyIdentifier" => "2.5.29.32.0", "CPS.1" => "https://www.verisign.com/cps");

my $CA_NAME = "default_ca";
my %CA = ("new_certs_dir" => $CACERT_DIR, "crlnumber" => "$CRLSERIAL_FILE.<<NAME>>", "database" => "$DATABASE_FILE.<<NAME>>", "email_in_dn" => "no", "policy" => $POLICY_NAME, "serial" => "$SERIAL_FILE.<<NAME>>", "default_days" => "365", "unique_subject" => "no", "default_md" => $MD, "default_crl_days" => "1", "default_crl_hours" => "24");

my %BASIC_EXT = ("prompt" => "no", "default_ca" => $CA_NAME, "oid_section" => "new_oids");

my $EXT_NAME = "ext";

my $OCSP_PORT = 9000;
my $OCSP_PORT_STAPLED_OFFSET = 10000;
my @OCSP_COMMANDS = ();

if ($#ARGV < 0) {
  die("Usage: $! config-file [config-file [config-file ... ] ]");
}

my %sections = ();

my $merge = Hash::Merge->new('LEFT_PRECEDENT');

my $DEFAULT_FILE = "defaults.json";
my $DEFAULT = decode_json(read_file($DEFAULT_FILE));

my $DEFAULTCA_FILE = "defaults-ca.json";
my $DEFAULTCA = $merge->merge(decode_json(read_file($DEFAULTCA_FILE)), clone($DEFAULT));

my $ROOT_FILE = "root.json";

mkdir($KEY_DIR);
mkdir($CACERT_DIR);
mkdir($CERT_DIR);
mkdir($CSR_DIR);
mkdir($OUT_DIR);

my $FAILURE = "<font color='red'>&#x2717;</font>";
my $SUCCESS = "<font color='green'>&#x2713;</font>";
my @jsf = ();
my @jsl = ();
my @jsp = ();

my $nginxbase = <<"EOF";
worker_processes 2;
pid /home/jlok/ssl/logs/nginx.<<FQDN>>.pid;
daemon off;
error_log /home/jlok/ssl/logs/error-<<FQDN>>.log;
  
events {
  worker_connections 768;
}       
  
http {
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;
  
  server_names_hash_bucket_size 1024;

  include /etc/nginx/mime.types;
  default_type application/octet-stream;  

  access_log /home/jlok/ssl/logs/access-<<FQDN>>.log;
  error_log /home/jlok/ssl/logs/access-<<FQDN>>.error.log;
    
  gzip on;
  gzip_disable "msie6";

EOF

my $nginxconfig = <<"EOF";
  server {
    listen 80;
    server_name $ROOT;

    root $DATA_DIR;
    index index.html index.htm;

    location / {
      ssi on;
      etag off;
      if_modified_since off;
      add_header 'Access-Control-Allow-Origin' '*';
      add_header 'Cache-Control' 'no-cache';
    }
  }
EOF

sub get_base {
  my ($name) = @_;

  my $base = $nginxbase;
  $base =~ s/<<FQDN>>/$name/g;
  return $base;
}

open(F, "> $OUT_DIR/nginx/$ROOT:80");
print F get_base("$ROOT:80") . $nginxconfig . "}\n";
close(F);

push @OCSP_COMMANDS, "/usr/sbin/nginx -c $OUT_DIR/nginx/$ROOT:80";

# FIRST MAKE ROOT CERT
my $hash = $merge->merge(decode_json(read_file($ROOT_FILE)), clone($DEFAULTCA));

# MAKE ROOT KEYPAIR/CERT IF NOT EXIST
new_ca_key("root");
if ((! -e "$KEY_DIR/root.key") || (! -e "$CERT_DIR/root.crt")) {
  run_command("openssl genrsa -out $KEY_DIR/root.key $hash->{key}->{length}");
  
  # MAKE ROOT CERT
  $hash->{extensions}->{crlDistributionPoints}->{include} = 0;
  make_conf_file("root", $hash);
  run_command("openssl req -new -x509 -days 3650 -config $CONF_FILE.root -key $KEY_DIR/root.key -$MD -extensions $EXT_NAME -out $CERT_DIR/root.crt");
  run_command("cp $CERT_DIR/root.crt $OUT_DIR/root.crt");
}

# COUNTER
my $i=0;

# THEN PROCESS EACH FILE
foreach my $file (@ARGV) {
  my $name = "unknown";
  if ($file =~ m|([^\/]*)\.json|) { $name = $1; }

  my $FILE = decode_json(read_file($file));
  my @CERTS = @{ $FILE->{certificates} };
  my $chain = "";

  my $fqdn = "$name-$RUN$DOMAIN";
  if ($FILE->{domain}) {
    $fqdn = $FILE->{domain};
  }

  my $has_ocsp = 0;

  for(my $i=0; $i<=$#CERTS; $i++) {
    # MERGE WITH EITHER LEAF OR CA DEFAULTS
    my $hash = $merge->merge($CERTS[$i], clone($DEFAULT));
    if ($i < $#CERTS) {
      $hash = $merge->merge($CERTS[$i], clone($DEFAULTCA));
    }

    # MAKE KEYPAIR
    run_command("openssl genrsa -out $KEY_DIR/$name.$i.key $hash->{key}->{length}");

    # MAKE CSR
    my $prev = "$name." . ($i-1);
    if ($i == 0) {
      $prev = "root";
    }

    $chain = "$CERT_DIR/$prev.crt $chain";

    new_ca_key("$name.$i");
    if ($hash->{extensions}->{crlDistributionPoints}->{value} eq "URI:") {
      $hash->{extensions}->{crlDistributionPoints}->{value} = "URI:$CRL_PATH$prev.crl";
    }

    if (! $hash->{subject}->{CN}) {
      $hash->{subject}->{CN} = ($i < $#CERTS ? "Level $i intermediate CA ($name run $RUN)" : "$fqdn");
    }

    if ($hash->{extensions}->{subjectAltName}->{include}) {
      $hash->{extensions}->{subjectAltName}->{value} =~ s/<<FQDN>>/$name-$RUN$DOMAIN/g;
    }

    # SET UP OCSP RESOLVER, IF DESIRED
    if ($hash->{extensions}->{authorityInfoAccess}->{include}) {
      my $port = $OCSP_PORT++;
      # If the response is stapled and if this is the leaf cert, put it on a non-responding port
      if (($FILE->{stapled}) && ($i == $#CERTS)) {
        $port += $OCSP_PORT_STAPLED_OFFSET;
      }

      $hash->{extensions}->{authorityInfoAccess}->{value} =~ s/<<OCSP>>/http:\/\/$fqdn:$port/g;
      $hash->{extensions}->{authorityInfoAccess}->{value} =~ s/<<PARENTCERT>>/http:\/\/test.sslresearch.org\/certs\/$prev.crt/g;

      my $unknown = "";
      if ($hash->{unknown}) {
        $unknown = "-unknown";
      }

      push @OCSP_COMMANDS, "openssl ocsp $unknown -resp_key_id -sha1 -ignore_err -ndays 1 -index $DATABASE_FILE.$prev -url http://test.sslresearch.org:$port -rsigner $CERT_DIR/$prev.crt -rkey $KEY_DIR/$prev.key -CA $CERT_DIR/$prev.crt -text -out .ocsplog.$prev.txt";

      $has_ocsp = 1;
    } else {
      $has_ocsp = 0;
    }

#    $hash->{subject}->{serialNumber} = $RUN;
#    $hash->{subject}->{serialNumber} = int(rand($RUN));

    make_conf_file("$prev", $hash);
    run_command("openssl req -new -$MD -config $CONF_FILE.$prev -key $KEY_DIR/$name.$i.key -out $CSR_DIR/$name.$i.csr");

    # MAKE CERT
    run_command("openssl ca -preserveDN -batch -startdate $hash->{validity}->{start} -enddate $hash->{validity}->{end} -config $CONF_FILE.$prev -keyfile $KEY_DIR/$prev.key -cert $CERT_DIR/$prev.crt -extensions $EXT_NAME -notext -md $MD -in $CSR_DIR/$name.$i.csr -out $CERT_DIR/$name.$i.crt");

    # REVOKE IF NECESSARY
    if ($hash->{revoked}) {
      run_command("openssl ca -batch -config $CONF_FILE.$prev -keyfile $KEY_DIR/$prev.key -cert $CERT_DIR/$prev.crt -revoke $CERT_DIR/$name.$i.crt");
    }

    # REGENERATE CRL
    run_command("openssl ca -batch -config $CONF_FILE.$prev -keyfile $KEY_DIR/$prev.key -cert $CERT_DIR/$prev.crt -gencrl -crldays 21 -out $DATA_DIR/crls/$RUN-$prev.crl.pem");
    run_command("openssl crl -inform pem -in $DATA_DIR/crls/$RUN-$prev.crl.pem -outform der -out $DATA_DIR/crls/$RUN-$prev.crl");
  }

  if (! ($chain eq "")) {
    run_command("cat $chain > $OUT_DIR/$name.chain.crt");
  } else {
    run_command("rm $OUT_DIR/$name.chain.crt; touch $OUT_DIR/$name.chain.crt");
  }
  run_command("cp $CERT_DIR/$name.$#CERTS.crt $OUT_DIR/$name.leaf.crt");
  run_command("cat $OUT_DIR/$name.leaf.crt $chain > $OUT_DIR/$name.full.crt");
  run_command("cp $KEY_DIR/$name.$#CERTS.key $OUT_DIR/$name.key");

  my $stapling = "    ssl_stapling off;";
#  if (($FILE->{stapled} && $has_ocsp) || $FILE->{default}) {
  if ($FILE->{stapled} && $has_ocsp) {
    $stapling = "    ssl_stapling on;\n    ssl_stapling_verify on;";
  }

  my $default = "";
  if ($FILE->{default}) { 
    $default = " default_server"; 
  }

  my $nginxconfig = <<"EOF";
  server {
    listen $FILE->{port} ssl$default;
    server_name $fqdn;

    root $DATA_DIR;
    index index.html index.htm;

    ssl_certificate $OUT_DIR/$name.full.crt;
EOF

  if (! ($chain eq "")) {
    $nginxconfig .= <<"EOF";
    ssl_client_certificate $OUT_DIR/$name.chain.crt;
    ssl_trusted_certificate $OUT_DIR/$name.chain.crt;
EOF
  }

  $nginxconfig .= <<"EOF";
    ssl_certificate_key $OUT_DIR/$name.key;
$stapling

    location / {
      ssi on;
      etag off;
      if_modified_since off;
      add_header 'Access-Control-Allow-Origin' '*';
      add_header 'Cache-Control' 'no-cache';
    }
  }
EOF

  open(F, "> $OUT_DIR/nginx/$fqdn:$FILE->{port}");
  print F get_base("$fqdn:$FILE->{port}") . $nginxconfig . "}\n";
  close(F);

  push @OCSP_COMMANDS, "/usr/sbin/nginx -c $OUT_DIR/nginx/$fqdn:$FILE->{port}";

  if ((! $FILE->{include}) || ($FILE->{include} eq "yes")) {
    my $html .= "<tr><td width=600>$FILE->{name} <small>(<a href='https://$fqdn:$FILE->{port}/test.json'>$name</a>)</small></td><td><span id=\"$name-$RUN\"></span></td></tr>\n";
    if ($FILE->{section}) {
     if ($FILE->{subsection}) {
       $sections{$FILE->{section}}{$FILE->{subsection}}{$FILE->{name}} .= $html;
     } else {
       $sections{$FILE->{section}}{""}{$FILE->{name}} .= $html;
     }
    } else {
      $sections{""}{""}{$FILE->{name}} .= $html;
    }

    push @jsf, "$name-$RUN";
    push @jsl, $FILE->{expectation};
    push @jsp, $FILE->{port};

#    if ($FILE->{stapled}) {
#      push @jsf, $name;
#      push @jsl, $FILE->{expectation};
#      push @jsp, $FILE->{port};
#    }
  }

  $i++;
}

run_command("cp $OUT_DIR/root.crt $DATA_DIR/root.crt");

open(F, "> $DATA_DIR/include.html");
print F "<script src='http://cdnjs.cloudflare.com/ajax/libs/jquery-ajaxtransport-xdomainrequest/1.0.3/jquery.xdomainrequest.min.js'></script>";
print F "<span id='message'>Testing for root certificate...</span>\n";
foreach my $section (sort keys %sections) {
  print F "<h3>$section</h3>\n";
  foreach my $subsection (sort keys %{ $sections{$section} }) {
    print F "<table>";
    print F "<h5>$subsection</h5>\n";
    foreach my $test (sort keys %{ $sections{$section}{$subsection} }) {
      print F $sections{$section}{$subsection}{$test} . "\n";
    }
    print F "</table>";
  }
}
print F "<script>\n  Date.now = Date.now || function() { return +new Date; };\n  var list = [\"" . join("\", \"", @jsf) . "\"];\n  var outcomes = [\"" . join("\", \"", @jsl) . "\"];\n  var ports = [\"" . join("\", \"", @jsp) . "\"];\n";
print F <<"END_JS";
  var done = 0;
  var results = {};
  results["user-agent"] = navigator.userAgent;

  function upload() {
    var json = JSON.stringify(results); 

    \$.ajax({
      type: "POST",
      url: "/results/post.php",
      data: json,
      contentType: "application/json; charset=utf-8",
      dataType: "json"
    });
  }

  function doNext(last) {
    done++;
    if (list.length > 0) {
      \$('#count').text(done);
      var next = list.pop();
      var start = Date.now();
      var outcome = outcomes.pop();
      var port = ports.pop();
      \$.ajax("https://" + next + "$DOMAIN:" + port + "/test.json", {
         "timeout": 121000,
         "success": function(data, status, xhr) { var end = Date.now(); \$( "#" + next ).html((outcome == "pass" ? "<font color='green'>&#x2713;</font>" : "<font color='red'>&#x2717;</font>") + " " + status + "/" + data); results[next] = [(outcome == "pass" ? "PASS" : "FAIL"), end-start]; },
         "error": function(xhr, status, error) { var end = Date.now(); \$( "#" + next ).html((outcome == "fail" ? "<font color='green'>&#x2713;</font>" : "<font color='red'>&#x2717;</font>") + " " + status + "/" + error); results[next] = [(outcome == "fail" ? "PASS" : "FAIL"), end-start]; },
         "complete": function() { doNext(next); }
      });
    } else {
      upload();
    }
  }

  \$.ajax("https://$ROOT/test.json", { 
    "timeout": 5000,
    "success": function() { \$("#message").html("Root certificate verified. Running tests...  (<span id='count'>0</span>/<span id='total'>Unknown</span> completed)"); \$('#total').text(list.length); doNext(); },
    "error": function() { \$("#message").html("<font color='red'>Root certificate does not appeared to be installed.</font>  Download and install the root certificate at <a href='root.crt'>root.crt</a>.  Test <a href='https://$ROOT/test.json'>here</a>."); }
  });
</script>
END_JS
#my $start = shift @jsf;
#print F "$start()";
#foreach my $f (@jsf) {
#  print F ".then($f,$f)";
#}
#print F ";\n</script>\n";
close(F);

my $sel = IO::Select->new();

push @OCSP_COMMANDS, "tcpserver 0 $NORESPONSE_PORT echo";

foreach my $cmd (@OCSP_COMMANDS) {
  my ($wt, $rd, $err);
  print "Running '$cmd'\n";
  my $pid = open3($wt, $rd, $err, $cmd);
  $sel->add($rd);
  $sel->add($err);
}

sleep(2);

while(1) {
  my @ready = $sel->can_read(1000);
  
  foreach my $fh (@ready) {
    print $fh->getline();
  }
}

sub make_conf_file {
  my ($name, $hash) = @_;

  open(F, "> $CONF_FILE.$name");
  print F conf_section("", \%BASIC_EXT);

  my %myca = %CA;
  foreach my $k (keys %myca) {
    if ($myca{$k} =~ m|<<NAME>>|) {
      $myca{$k} =~ s/<<NAME>>/$name/g;
    }
  }

  print F conf_section($CA_NAME, \%myca);
  print F conf_section($OIDS_NAME, \%OIDS);
  print F conf_section($POLICY_NAME, \%POLICY);
  print F conf_section($CERTPOL_NAME, \%CERTPOL);
  print F conf_section($DIRNAME_NAME, \%DIRNAME);
  print F conf_section($CACERTPOL_NAME, \%CACERTPOL);

  print F conf_heading("req");
  print F conf_line("distinguished_name", $EXT_NAME . "_distinguished_name");

  print F conf_heading($EXT_NAME);
  my $ext = $hash->{extensions};
  foreach my $key (sort {$ext->{$a}->{order} <=> $ext->{$b}->{order}} keys %{ $ext }) { 
    if ($ext->{$key}->{include} == 1) {
      print F conf_line($key, $ext->{$key}->{value});
    }
  }

  print F conf_section($EXT_NAME . "_distinguished_name", $hash->{subject});

#  if ($hash->{subject}->{country}) { print F conf_line("C", $hash->{subject}->{country}); }
#  if ($hash->{subject}->{state}) { print F conf_line("ST", $hash->{subject}->{state}); }
#  if ($hash->{subject}->{locality}) { print F conf_line("L", $hash->{subject}->{locality}); }
#  if ($hash->{subject}->{organization}) { print F conf_line("O", $hash->{subject}->{organization}); }
#  if ($hash->{subject}->{organization_unit}) { print F conf_line("OU", $hash->{subject}->{organization_unit}); }
#  if ($hash->{subject}->{common_name}) { print F conf_line("CN", $hash->{subject}->{common_name}); }

  close(F);
}

sub new_ca_key {
  my ($name) = @_;

  open(F, "> $CRLSERIAL_FILE.$name"); print F sprintf("%08x", int(rand(1000000))) . "\n"; close(F);
  open(F, "> $SERIAL_FILE.$name"); print F sprintf("%08x", int(rand(1000000))) . "\n"; close(F);
  open(F, "> $DATABASE_FILE.$name"); close(F);
}

sub conf_section {
  my ($title, $hash) = @_;

  my $out = ($title ? conf_heading($title) : "");
  foreach my $key (keys %{ $hash }) { 
    $out .= conf_line($key, $hash->{$key});
  }

  return $out;
}

sub conf_line {
  my ($key, $value) = @_;
  $value =~ s/<<DOMAIN>>/$DOMAIN/g;
  return "$key=$value\n";
}

sub conf_heading {
  my ($title) = @_;
  return "\n[ $title ]\n";
}

sub read_file {
  my ($file) = @_;

  if (! -e $file) {
    die("Unable to read file '$file'");
  }

  my $result = "";
  open(F, $file); 
  while(<F>) { 
    $result .= $_; 
  } 
  close(F);

  return $result;
}

sub run_command {
  my ($command) = @_;

  print "Running $command\n";

  my $output = qx($command 2>&1);
  my $exitcode = $? >> 8;

  if ($exitcode) {
    print "$output\n";
    die("Command '$command' exited with $exitcode");
  }

  return $output;
}
